<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>React关键问题01</title>
  <meta name="description" content="基础问题1. 什么是ReactReact 是一个开源前端 JavaScript 库，用于构建用户界面，尤其是单页应用程序。它用于处理网页和移动应用程序的视图层。2. React的主要特点是什么React 的主要特性有：考虑到真实的 DOM 操作成本很高，它使用 VirtualDOM 而不是真实的 DOM。支持服务...">
  <!-- evil icon -->

  <link rel="stylesheet" href="/assets/evil-icons.min.css">
  <script src="/assets/evil-icons.min.js"></script>

  <!-- todo: include this into main.css -->

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://mark24code.github.io/%E5%89%8D%E7%AB%AF/react/2020/04/18/React%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%9801.html">
  <link rel="alternate" type="application/rss+xml" title="Mark24" href="https://mark24code.github.io/feed.xml">

  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5H3S9CQNF0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5H3S9CQNF0');
</script>


</head>

  <body>
    <div class="page-content">
      <div class="container">
        <div class="three columns">
          <header class="site-header">

  <h2 class="logo"><a href="/">Mark24</a></h2>
  <div class="description">记录灵感、技术、思考</div>

  <div class="nav">
    
    <label for="menu-toggle" class="menu-icon">
        <!--div data-icon="ei-navicon"></div-->
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
    </label>
    <input type="checkbox" id="menu-toggle">

    <div class="site-nav">
      <nav>
        <ul class="page-link">
          <li><a href="/">Home</a></li>
          <li><a href="/posts">Posts</a></li>
          <li><a href="/art">Art</a></li>
          <li><a href="https://speakerdeck.com/mark24code">Sliders</a></li>
          <li><a href="/sites">Sites</a></li>
          <li><a href="/feed.xml">RSS</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </nav>
    </div>

    <section class="small-font">
      
      <a href="https://github.com/Mark24Code"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span></a>

      
      
    </section>
  </div>
</header>

        </div>

        <div class="nine columns" style="z-index:100;">
          <div class="wrapper">
            <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="artilce_header">
    <h1 class="artilce_title" itemprop="name headline">React关键问题01</h1>
    <p class="artilce_meta"><time datetime="2020-04-18T12:45:45+08:00" itemprop="datePublished">Apr 18, 2020</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Mark24</span></span></p>
  </header>

  <div class="article-content" itemprop="articleBody">
    <h1 id="基础问题">基础问题</h1>

<h1 id="1-什么是react">1. 什么是React</h1>

<p>React 是一个开源前端 JavaScript 库，用于构建用户界面，尤其是单页应用程序。它用于处理网页和移动应用程序的视图层。</p>

<h1 id="2-react的主要特点是什么">2. React的主要特点是什么</h1>

<p>React 的主要特性有：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>考虑到真实的 DOM 操作成本很高，它使用 VirtualDOM 而不是真实的 DOM。
支持服务端渲染。
遵循单向数据流或数据绑定。
使用可复用/可组合的 UI 组件开发视图。
</code></pre></div></div>

<h1 id="3-什么是jsx">3. 什么是JSX?</h1>

<p>JSX 是 ECMAScript 一个类似 XML 的语法扩展。基本上，它只是为 React.createElement() 函数提供语法糖，从而让在我们在 JavaScript 中，使用类 HTML 模板的语法，进行页面描述。</p>

<p>在下面的示例中，&lt;h1&gt; 内的文本标签会作为 JavaScript 函数返回给渲染函数。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="dl">'</span><span class="s1">Welcome to React world!</span><span class="dl">'</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以上示例 render 方法中的 JSX 将会被转换为以下内容：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">div</span><span class="dl">"</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
  <span class="dl">"</span><span class="s2">h1</span><span class="dl">"</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Welcome to React world!</span><span class="dl">'</span><span class="p">));</span>
</code></pre></div></div>

<p>这里你可以访问 <a href="https://babeljs.io/repl">Babeljs</a> 在线体验一下。</p>

<h2 id="参考">参考：</h2>

<ul>
  <li><a href="https://github.com/hujiulong/blog/issues/4">从零开始实现一个React（一）：JSX和虚拟DOM</a></li>
</ul>

<h1 id="4-元素和组件有什么区别">4. 元素和组件有什么区别?</h1>

<p>一个 Element 是一个简单的对象，它描述了你希望在屏幕上以 DOM 节点或其他组件的形式呈现的内容。Elements 在它们的属性中可以包含其他 Elements。创建一个 React 元素是很轻量的。一旦元素被创建后，它将不会被修改。</p>

<p>React Element 的对象表示如下：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">element</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">login-btn</span><span class="dl">'</span><span class="p">},</span>
  <span class="dl">'</span><span class="s1">Login</span><span class="dl">'</span>
<span class="p">)</span>
</code></pre></div></div>

<p>上面的 <code class="language-plaintext highlighter-rouge">React.createElement()</code> 函数会返回一个对象。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Login</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">login-btn</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后使用 ReactDOM.render() 方法渲染到 DOM：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="p">=</span><span class="s">'login-btn'</span><span class="p">&gt;</span>Login<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>而一个组件可以用多种不同方式声明。它可以是一个含有 render() 方法的类。或者，在简单的情况中，它可以定义为函数。无论哪种情况，它都将 props 作为输入，并返回一个 JSX 树作为输出：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Button</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">onLogin</span> <span class="p">})</span> <span class="o">=&gt;</span>
  <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">login-btn</span><span class="dl">'</span><span class="si">}</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">onLogin</span><span class="si">}</span> <span class="p">/&gt;</span>
</code></pre></div></div>

<p>然后 JSX 被转换成 React.createElement() 函数：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Button</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">onLogin</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span>
  <span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">,</span>
  <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">login-btn</span><span class="dl">'</span><span class="p">,</span> <span class="na">onClick</span><span class="p">:</span> <span class="nx">onLogin</span> <span class="p">},</span>
  <span class="dl">'</span><span class="s1">Login</span><span class="dl">'</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="参考-1">参考</h2>

<ul>
  <li><a href="https://overreacted.io/zh-hans/why-do-react-elements-have-typeof-property/">为什么React元素有一个$$typeof属性?</a></li>
</ul>

<h1 id="5-如何在-react-中创建组件">5. 如何在 React 中创建组件?</h1>

<ol>
  <li>Function Components: 这是创建组件最简单的方式。这些是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Greeting</span><span class="p">({</span> <span class="nx">message</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="s2">`Hello, </span><span class="p">${</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>Class Components: 你还可以使用 ES6 类来定义组件。上面的函数组件若使用 ES6 的类可改写为：</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Greeting</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="s2">`Hello, </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过以上任意方式创建的组件，可以这样使用：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="p">&lt;</span><span class="nc">Greeting</span> <span class="na">message</span><span class="p">=</span><span class="s">"semlinker"</span><span class="p">/&gt;</span>
</code></pre></div></div>

<p>在 React 内部对函数组件和类组件的处理方式是不一样的，如：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 如果 Greeting 是一个函数</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">Greeting</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span> <span class="c1">// &lt;p&gt;Hello&lt;/p&gt;</span>

  <span class="c1">// 如果 Greeting 是一个类</span>
  <span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Greeting</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span> <span class="c1">// Greeting {}</span>
  <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span> <span class="c1">// &lt;p&gt;Hello&lt;/p&gt;</span>
</code></pre></div></div>

<h2 id="拓展">拓展</h2>

<ul>
  <li><a href="https://overreacted.io/zh-hans/how-does-react-tell-a-class-from-a-function/">React 如何区分 Class 和 Function？</a></li>
</ul>

<h1 id="什么是-pure-components">什么是 Pure Components?</h1>

<p>React.PureComponent 与 React.Component 完全相同，只是它为你处理了 shouldComponentUpdate() 方法。当属性或状态发生变化时，PureComponent 将对属性和状态进行浅比较。另一方面，一般的组件不会将当前的属性和状态与新的属性和状态进行比较。因此，在默认情况下，每当调用 shouldComponentUpdate 时，默认返回 true，所以组件都将重新渲染。</p>

<h1 id="状态和属性有什么区别">状态和属性有什么区别?</h1>

<p>state 和 props 都是普通的 JavaScript 对象。虽然它们都保存着影响渲染输出的信息，但它们在组件方面的功能不同。Props 以类似于函数参数的方式传递给组件，而状态则类似于在函数内声明变量并对它进行管理。</p>

<h1 id="回调函数作为-setstate-参数的目的是什么">回调函数作为 setState() 参数的目的是什么?</h1>

<p>当 setState 完成和组件渲染后，回调函数将会被调用。由于 setState() 是异步的，回调函数用于任何后续的操作。</p>

<h1 id="html-和-react-事件处理有什么区别">HTML 和 React 事件处理有什么区别?</h1>

<p>1.在 HTML 中事件名必须小写：</p>

<p><code class="language-plaintext highlighter-rouge">&lt;button onclick='activateLasers()'&gt;</code></p>

<p>而在 React 中它遵循 camelCase (驼峰) 惯例：</p>

<p><code class="language-plaintext highlighter-rouge">&lt;button onClick={activateLasers}&gt;</code></p>

<p>2.在 HTML 中你可以返回 false 以阻止默认的行为：</p>

<p><code class="language-plaintext highlighter-rouge">&lt;a href='#' onclick='console.log("The link was clicked."); return false;' /&gt;</code></p>

<p>而在 React 中你必须地明确地调用 preventDefault() ：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleClick</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">The link was clicked.</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="如何在-jsx-回调中绑定方法或事件处理程序">如何在 JSX 回调中绑定方法或事件处理程序?</h1>

<p>实现这一点有三种可能的方法：</p>

<ol>
  <li>Binding in Constructor: 在 JavaScript 类中，方法默认不被绑定。这也适用于定义为类方法的 React 事件处理程序。通常我们在构造函数中绑定它们。</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Component</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Componenet</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">handleClick</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>Public class fields syntax: 如果你不喜欢 bind 方案，则可以使用 public class fields syntax 正确绑定回调。</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">this is:</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
  <span class="si">{</span><span class="dl">'</span><span class="s1">Click me</span><span class="dl">'</span><span class="si">}</span>
<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</code></pre></div></div>

<ol>
  <li>Arrow functions in callbacks: 你可以在回调函数中直接使用 arrow functions。</li>
</ol>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
  <span class="si">{</span><span class="dl">'</span><span class="s1">Click me</span><span class="dl">'</span><span class="si">}</span>
<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>注意： 如果回调函数作为属性传给子组件，那么这些组件可能触发一个额外的重新渲染。在这些情况下，考虑到性能，最好使用 .bind() 或 public class fields syntax 方案。</p>

<h1 id="如何将参数传递给事件处理程序或回调函数">如何将参数传递给事件处理程序或回调函数?</h1>

<p>你可以使用箭头函数来包装事件处理器并传递参数：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span><span class="si">}</span> <span class="p">/&gt;</span>
</code></pre></div></div>
<p>这相当于调用 <code class="language-plaintext highlighter-rouge">.bind</code>:</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span><span class="si">}</span> <span class="p">/&gt;</span>
</code></pre></div></div>

<h1 id="react-中的合成事件是什么">React 中的合成事件是什么?</h1>

<p><code class="language-plaintext highlighter-rouge">SyntheticEvent</code> 是对浏览器原生事件的跨浏览器包装。它的 API 与浏览器的原生事件相同，包括 <code class="language-plaintext highlighter-rouge">stopPropagation()</code>和 <code class="language-plaintext highlighter-rouge">preventDefault()</code>，除了事件在所有浏览器中的工作方式相同。</p>

<h1 id="什么是内联条件表达式">什么是内联条件表达式?</h1>

<p>在 JS 中你可以使用 if 语句或三元表达式，来实现条件判断。除了这些方法之外，你还可以在 JSX 中嵌入任何表达式，方法是将它们用大括号括起来，然后再加上 JS 逻辑运算符 &amp;&amp;。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="nx">messages</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">isLogin</span> <span class="p">?</span>
      <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>
          You have <span class="si">{</span><span class="nx">messages</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span> unread messages.
      <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
      <span class="p">:</span>
      <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>
          You don't have unread messages.
      <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>当然如果只是想判断 if，可以如下直接判断：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="nx">isLogin</span> <span class="o">&amp;&amp;</span> <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>Your have been login!<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="什么是-key-属性在元素数组中使用它们有什么好处">什么是 “key” 属性，在元素数组中使用它们有什么好处?</h1>

<p>key 是一个特殊的字符串属性，你在创建元素数组时需要包含它。Keys 帮助 React 识别哪些项已更改、添加或删除。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">todoItems</span> <span class="o">=</span> <span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">todo</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="p">&lt;</span><span class="nt">li</span> <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">todo</span><span class="p">.</span><span class="nx">id</span><span class="si">}</span><span class="p">&gt;</span>
    <span class="si">{</span><span class="nx">todo</span><span class="p">.</span><span class="nx">text</span><span class="si">}</span>
  <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="p">)</span>
</code></pre></div></div>
<p>在渲染列表项时，如果你没有稳定的 IDs，你可能会使用 index 作为 key：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">todoItems</span> <span class="o">=</span> <span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">todo</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="p">&lt;</span><span class="nt">li</span> <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">index</span><span class="si">}</span><span class="p">&gt;</span>
    <span class="si">{</span><span class="nx">todo</span><span class="p">.</span><span class="nx">text</span><span class="si">}</span>
  <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="p">)</span>
</code></pre></div></div>

<p>注意</p>

<blockquote>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>由于列表项的顺序可能发生改变，因此并不推荐使用 indexes 作为 keys。这可能会对性能产生负面影响，并可能导致组件状态出现问题。
如果将列表项提取为单独的组件，则在列表组件上应用 keys 而不是 li 标签。
如果在列表项中没有设置 key 属性，在控制台会显示警告消息。
</code></pre></div>  </div>
</blockquote>

<h1 id="refs-有什么用">refs 有什么用?</h1>

<p>ref 用于返回对元素的引用。但在大多数情况下，应该避免使用它们。当你需要直接访问 DOM 元素或组件的实例时，它们可能非常有用。</p>

<h1 id="什么是-forward-refs">什么是 forward refs?</h1>

<p>Ref forwarding 是一个特性，它允许一些组件获取接收到 ref 对象并将它进一步传递给子组件。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">ButtonElement</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">forwardRef</span><span class="p">((</span><span class="nx">props</span><span class="p">,</span> <span class="nx">ref</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="p">&lt;</span><span class="nt">button</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">ref</span><span class="si">}</span> <span class="na">className</span><span class="p">=</span><span class="s">"CustomButton"</span><span class="p">&gt;</span>
    <span class="si">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="si">}</span>
  <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">));</span>

<span class="c1">// Create ref to the DOM button:</span>
<span class="kd">const</span> <span class="nx">ref</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createRef</span><span class="p">();</span>
<span class="p">&lt;</span><span class="nc">ButtonElement</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">ref</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="dl">'</span><span class="s1">Forward Ref</span><span class="dl">'</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">ButtonElement</span><span class="p">&gt;</span>
</code></pre></div></div>

<h1 id="callback-refs-和-finddomnode-哪一个是首选选项">callback refs 和 findDOMNode() 哪一个是首选选项?</h1>

<p>最好是使用 callback refs 而不是 findDOMNode() API。因为 findDOMNode() 阻碍了将来对 React 的某些改进。</p>

<p>使用 findDOMNode 已弃用的方案：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">findDOMNode</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">scrollIntoView</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="p">/&gt;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>推荐的方案是：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">scrollIntoView</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">node</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="si">}</span> <span class="p">/&gt;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="为什么-string-refs-被弃用">为什么 String Refs 被弃用?</h1>

<p>如果你以前使用过 React，你可能会熟悉旧的 API，其中的 ref 属性是字符串，如 ref={‘textInput’}，并且 DOM 节点的访问方式为this.refs.textInput。我们建议不要这样做，因为字符串引用有以下问题，并且被认为是遗留问题。字符串 refs 在 React v16 版本中被移除。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 它们强制 React 跟踪当前执行的组件。这是有问题的，因为它使 React 模块有状态，这会导致在 bundle 中复制 React 模块时会导致奇怪的错误。

* 它们是不可组合的 - 如果一个库把一个 ref 传给子元素，则用户无法对其设置另一个引用。

* 它们不能与静态分析工具一起使用，如 Flow。Flow 无法猜测出 this.refs 上的字符串引用的作用及其类型。Callback refs 对静态分析更友好。

* 使用 "render callback" 模式（比如： ），它无法像大多数人预期的那样工作。
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">renderRow</span> <span class="o">=</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// This won't work. Ref will get attached to DataTable rather than MyComponent:</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">input-</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">index</span><span class="si">}</span> <span class="p">/&gt;;</span>

    <span class="c1">// This would work though! Callback refs are awesome.</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">input</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">[</span><span class="dl">'</span><span class="s1">input-</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="si">}</span> <span class="p">/&gt;;</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nc">DataTable</span> <span class="na">data</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">data</span><span class="si">}</span> <span class="na">renderRow</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">renderRow</span><span class="si">}</span> <span class="p">/&gt;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="什么是-virtual-dom">什么是 Virtual DOM?</h1>

<p>Virtual DOM (VDOM) 是 Real DOM 的内存表示形式。UI 的展示形式被保存在内存中并与真实的 DOM 同步。这是在调用的渲染函数和在屏幕上显示元素之间发生的一个步骤。整个过程被称为 reconciliation。</p>

<h1 id="virtual-dom-如何工作">Virtual DOM 如何工作?</h1>

<p>Virtual DOM 分为三个简单的步骤。</p>

<ul>
  <li>每当任何底层数据发生更改时，整个 UI 都将以 Virtual DOM 的形式重新渲染。</li>
</ul>

<p><img src="/assets/blog/react/vdom1.png" alt="vdom1" /></p>

<ul>
  <li>然后计算新的 Virtual DOM 和 旧 Virtual DOM 对象之间的差异。</li>
</ul>

<p><img src="/assets/blog/react/vdom2.png" alt="vdom2" /></p>

<ul>
  <li>一旦计算完成，真实的 DOM 将只更新实际更改的内容</li>
</ul>

<p><img src="/assets/blog/react/vdom3.png" alt="vdom3" /></p>

<h2 id="什么是-react-fiber">什么是 React Fiber?</h2>

<p>Fiber 是 React v16 中新的 reconciliation 引擎，或核心算法的重新实现。React Fiber 的目标是提高对动画，布局，手势，暂停，中止或者重用任务的能力及为不同类型的更新分配优先级，及新的并发原语等领域的适用性。</p>

<h1 id="react-fiber-的主要目标是什么">React Fiber 的主要目标是什么?</h1>

<p>React Fiber 的目标是提高其在动画、布局和手势等领域的适用性。它的主要特性是 incremental rendering: 将渲染任务拆分为小的任务块并将任务分配到多个帧上的能力。</p>

<h1 id="什么是受控组件">什么是受控组件?</h1>

<p>在随后的用户输入中，能够控制表单中输入元素的组件被称为受控组件，即每个状态更改都有一个相关联的处理程序。</p>

<p>例如，我们使用下面的 handleChange 函数将输入框的值转换成大写：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleChange</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span><span class="na">value</span><span class="p">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">()})</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="什么是非受控组件">什么是非受控组件?</h1>

<p>非受控组件是在内部存储其自身状态的组件，当需要时，可以使用 ref 查询 DOM 并查找其当前值。这有点像传统的 HTML。</p>

<p>在下面的 UserProfile 组件中，我们通过 ref 引用 name 输入框：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">class</span> <span class="nx">UserProfile</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">handleSubmit</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleSubmit</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">input</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createRef</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">handleSubmit</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="s1">A name was submitted: </span><span class="dl">'</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">input</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">form</span> <span class="na">onSubmit</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleSubmit</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">label</span><span class="p">&gt;</span>
          <span class="si">{</span><span class="dl">'</span><span class="s1">Name:</span><span class="dl">'</span><span class="si">}</span>
          <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="p">=</span><span class="s">"text"</span> <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">input</span><span class="si">}</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">label</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="p">=</span><span class="s">"submit"</span> <span class="na">value</span><span class="p">=</span><span class="s">"Submit"</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在大多数情况下，建议使用受控组件来实现表单。</p>

<h1 id="createelement-和-cloneelement-有什么区别">createElement 和 cloneElement 有什么区别?</h1>

<p>JSX 元素将被转换为 React.createElement() 函数来创建 React 元素，这些对象将用于表示 UI 对象。而 cloneElement 用于克隆元素并传递新的属性。</p>

<h1 id="在-react-中的提升状态是什么">在 React 中的提升状态是什么?</h1>

<p>当多个组件需要共享相同的更改数据时，建议将共享状态提升到最接近的共同祖先。这意味着，如果两个子组件共享来自其父组件的相同数据，则将状态移动到父组件，而不是在两个子组件中维护局部状态。</p>

<h1 id="组件生命周期的不同阶段是什么">组件生命周期的不同阶段是什么?</h1>

<h2 id="-mounting">* Mounting</h2>

<p>组件已准备好挂载到浏览器的 DOM 中. 此阶段包含来自 constructor(), getDerivedStateFromProps(), render(), 和 componentDidMount() 生命周期方法中的初始化过程。</p>

<h2 id="-updating">* Updating</h2>

<p>在此阶段，组件以两种方式更新，发送新的属性并使用 setState() 或 forceUpdate() 方法更新状态. 此阶段包含 getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate() 和 componentDidUpdate() 生命周期方法。</p>

<p>## * Unmounting</p>

<p>在这个最后阶段，不需要组件，它将从浏览器 DOM 中卸载。这个阶段包含 componentWillUnmount() 生命周期方法。</p>

<p>值得一提的是，在将更改应用到 DOM 时，React 内部也有阶段概念。它们按如下方式分隔开：</p>

<ul>
  <li>
    <p>Render 组件将会进行无副作用渲染。这适用于纯组件（Pure Component），在此阶段，React 可以暂停，中止或重新渲染。</p>
  </li>
  <li>
    <p>Pre-commit 在组件实际将更改应用于 DOM 之前，有一个时刻允许 React 通过getSnapshotBeforeUpdate()捕获一些 DOM 信息（例如滚动位置）。</p>
  </li>
  <li>
    <p>Commit React 操作 DOM 并分别执行最后的生命周期： componentDidMount() 在 DOM 渲染完成后调用, componentDidUpdate() 在组件更新时调用, componentWillUnmount() 在组件卸载时调用。 React 16.3+ 阶段 (也可以看{交互式版本](projects.wojtekmaj.pl/react-lifecycle-methods-diagram/))</p>
  </li>
</ul>

<p>React 16.3 之后</p>

<p><img src="/assets/blog/react/react16.3.jpg" alt="react16.3" /></p>

<p>React 16.3 之前</p>

<p><img src="/assets/blog/react/react16.2.png" alt="react16.2" /></p>

<h1 id="react-生命周期方法有哪些">React 生命周期方法有哪些?</h1>

<h2 id="react-163">React 16.3+</h2>

<ul>
  <li>getDerivedStateFromProps: 在调用render()之前调用，并在 每次 渲染时调用。 需要使用派生状态的情况是很罕见得。值得阅读 <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">如果你需要派生状态</a>.</li>
  <li>componentDidMount: 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。</li>
  <li>shouldComponentUpdate: 确定组件是否应该更新。 默认情况下，它返回true。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回false值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。</li>
  <li>getSnapshotBeforeUpdate: 在最新的渲染输出提交给 DOM 前将会立即调用，这对于从 DOM 捕获信息（比如：滚动位置）很有用。</li>
  <li>componentDidUpdate: 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果shouldComponentUpdate()返回false，则不会触发。</li>
  <li>componentWillUnmount 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。</li>
</ul>

<h1 id="react-163-之前">React 16.3 之前</h1>

<ul>
  <li>componentWillMount: 在组件render()前执行，用于根组件中的应用程序级别配置。应该避免在该方法中引入任何的副作用或订阅。</li>
  <li>componentDidMount: 首次渲染后调用，所有得 Ajax 请求、DOM 或状态更新、设置事件监听器都应该在此处发生。</li>
  <li>componentWillReceiveProps: 在组件接收到新属性前调用，若你需要更新状态响应属性改变（例如，重置它），你可能需对比this.props和nextProps并在该方法中使用this.setState()处理状态改变。</li>
  <li>shouldComponentUpdate: 确定组件是否应该更新。 默认情况下，它返回true。 如果你确定在更新状态或属性后不需要渲染组件，则可以返回false值。 它是一个提高性能的好地方，因为它允许你在组件接收新属性时阻止重新渲染。</li>
  <li>componentWillUpdate: 当shouldComponentUpdate返回true后重新渲染组件之前执行，注意你不能在这调用this.setState()</li>
  <li>componentDidUpdate: 它主要用于更新 DOM 以响应 prop 或 state 更改。 如果shouldComponentUpdate()返回false，则不会触发。</li>
  <li>componentWillUnmount: 当一个组件被从 DOM 中移除时，该方法被调用，取消网络请求或者移除与该组件相关的事件监听程序等应该在这里进行。</li>
</ul>

<h1 id="什么是高阶组件hoc">什么是高阶组件（HOC）?</h1>

<p>高阶组件(HOC) 就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种模式，这种模式是由react自身的组合性质必然产生的。</p>

<p>我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">EnhancedComponent</span> <span class="o">=</span> <span class="nx">higherOrderComponent</span><span class="p">(</span><span class="nx">WrappedComponent</span><span class="p">)</span>
</code></pre></div></div>

<p>HOC 有很多用例：</p>

<ol>
  <li>代码复用，逻辑抽象化</li>
  <li>渲染劫持</li>
  <li>抽象化和操作状态（state）</li>
  <li>操作属性（props）</li>
</ol>

<h3 id="拓展-1">拓展</h3>

<ul>
  <li><a href="https://react.docschina.org/docs/higher-order-components.html">React HOC</a></li>
</ul>

<h1 id="如何为高阶组件创建属性代理">如何为高阶组件创建属性代理?</h1>

<p>你可以使用属性代理模式向输入组件增加或编辑属性（props）：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">HOC</span><span class="p">(</span><span class="nx">WrappedComponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">class</span> <span class="nx">Test</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">newProps</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">title</span><span class="p">:</span> <span class="dl">'</span><span class="s1">New Header</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">footer</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">showFeatureX</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">showFeatureY</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">};</span>

      <span class="k">return</span> <span class="p">&lt;</span><span class="nc">WrappedComponent</span> <span class="si">{</span><span class="p">...</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="si">}</span> <span class="si">{</span><span class="p">...</span><span class="nx">newProps</span><span class="si">}</span> <span class="p">/&gt;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="什么是上下文context">什么是上下文（Context）?</h1>

<p>Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递props。比如，需要在应用中许多组件需要访问登录用户信息、地区偏好、UI主题等。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个 theme Context,  默认 theme 的值为 light</span>
<span class="kd">const</span> <span class="nx">ThemeContext</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createContext</span><span class="p">(</span><span class="dl">'</span><span class="s1">light</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">ThemedButton</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ThemedButton 组件从 context 接收 theme</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">ThemeContext</span><span class="p">.</span><span class="nc">Consumer</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">theme</span> <span class="o">=&gt;</span> <span class="p">&lt;</span><span class="nc">Button</span> <span class="si">{</span><span class="p">...</span><span class="nx">props</span><span class="si">}</span> <span class="na">theme</span><span class="p">=</span><span class="si">{</span><span class="nx">theme</span><span class="si">}</span> <span class="p">/&gt;</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nc">ThemeContext</span><span class="p">.</span><span class="nc">Consumer</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 中间组件</span>
<span class="kd">function</span> <span class="nx">Toolbar</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">ThemedButton</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nc">ThemeContext</span><span class="p">.</span><span class="nc">Provider</span> <span class="na">value</span><span class="p">=</span><span class="s">"dark"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Toolbar</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">ThemeContext</span><span class="p">.</span><span class="nc">Provider</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="构造函数使用带-props-参数的目的是什么">构造函数使用带 props 参数的目的是什么?</h1>

<p>在调用super()方法之前，子类构造函数不能使用this引用。这同样适用于ES6子类。将props参数传递给super()的主要原因是为了在子构造函数中访问this.props。</p>

<h2 id="带-props-参数">带 props 参数:</h2>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">)</span> <span class="c1">// prints { name: 'John', age: 42 }</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="不带-props-参数">不带 props 参数:</h2>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">()</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">)</span> <span class="c1">// prints undefined</span>

    <span class="c1">// but props parameter is still available</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="c1">// prints { name: 'John', age: 42 }</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// no difference outside constructor</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">)</span> <span class="c1">// prints { name: 'John', age: 42 }</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码片段显示this.props仅在构造函数中有所不同。 它在构造函数之外是相同的。</p>

<h1 id="什么是调解协调reconciliation">什么是调解/协调(Reconciliation)</h1>

<p>当组件的props或state发生更改时，React 通过将新返回的元素与先前呈现的元素进行比较来确定是否需要实际的 DOM 更新。当它们不相等时，React 将更新 DOM 。此过程称为reconciliation。</p>

<h1 id="如何使用动态属性名设置-state-">如何使用动态属性名设置 state ?</h1>

<p>如果你使用 ES6 或 Babel 转换器来转换你的 JSX 代码，那么你可以使用计算属性名称来完成此操作。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleInputChange</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="p">[</span><span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">id</span><span class="p">]:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="每次组件渲染时调用函数的常见错误是什么">每次组件渲染时调用函数的常见错误是什么?</h1>

<p>你需要确保在将函数作为参数传递时未调用该函数。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Wrong: handleClick is called instead of passed as a reference!</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">()</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="dl">'</span><span class="s1">Click Me</span><span class="dl">'</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>相反地，传递函数本身应该没有括号：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Correct: handleClick is passed as a reference!</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="dl">'</span><span class="s1">Click Me</span><span class="dl">'</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="为什么有组件名称要首字母大写">为什么有组件名称要首字母大写?</h1>

<p>这是必要的，因为组件不是 DOM 元素，它们是构造函数。 此外，在 JSX 中，小写标记名称是指 HTML 元素，而不是组件。</p>

<h1 id="为什么-react-使用-classname-而不是-class-属性">为什么 React 使用 className 而不是 class 属性?</h1>

<p>class 是 JavaScript 中的关键字，而 JSX 是 JavaScript 的扩展。这就是为什么 React 使用 className 而不是 class 的主要原因。传递一个字符串作为 className 属性。</p>

<h1 id="什么是-fragments-">什么是 Fragments ?</h1>

<p>它是 React 中的常见模式，用于组件返回多个元素。Fragments 可以让你聚合一个子元素列表，而无需向 DOM 添加额外节点。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">React</span><span class="p">.</span><span class="nc">Fragment</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">ChildA</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">ChildB</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">ChildC</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nc">React</span><span class="p">.</span><span class="nc">Fragment</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以下是简洁语法，但是在一些工具中还不支持：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;&gt;</span>
      <span class="p">&lt;</span><span class="nc">ChildA</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">ChildB</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">ChildC</span> <span class="p">/&gt;</span>
    <span class="p">&lt;/&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>译注：React 16 以前，render 函数的返回必须有一个根节点，否则报错。</p>
</blockquote>

<h1 id="为什么使用-fragments-比使用容器-div-更好">为什么使用 Fragments 比使用容器 div 更好?</h1>

<ul>
  <li>通过不创建额外的 DOM 节点，Fragments 更快并且使用更少的内存。这在非常大而深的节点树时很有好处。</li>
  <li>一些 CSS 机制如Flexbox和CSS Grid具有特殊的父子关系，如果在中间添加 div 将使得很难保持所需的结构。</li>
  <li>在 DOM 审查器中不会那么的杂乱。</li>
</ul>

<h1 id="在-react-中什么是-portal-">在 React 中什么是 Portal ?</h1>

<p>Portal 提供了一种很好的将子节点渲染到父组件以外的 DOM 节点的方式。</p>

<p><code class="language-plaintext highlighter-rouge">ReactDOM.createPortal(child, container)</code></p>

<p>第一个参数是任何可渲染的 React 子节点，例如元素，字符串或片段。第二个参数是 DOM 元素。</p>

<h1 id="什么是无状态组件">什么是无状态组件?</h1>

<p>如果行为独立于其状态，则它可以是无状态组件。你可以使用函数或类来创建无状态组件。但除非你需要在组件中使用生命周期钩子，否则你应该选择函数组件。无状态组件有很多好处： 它们易于编写，理解和测试，速度更快，而且你可以完全避免使用this关键字。</p>

<h1 id="什么是有状态组件">什么是有状态组件?</h1>

<p>如果组件的行为依赖于组件的state，那么它可以被称为有状态组件。</p>

<h1 id="react-的优点是什么">React 的优点是什么?</h1>

<ul>
  <li>使用 Virtual DOM 提高应用程序的性能。</li>
  <li>JSX 使代码易于读写。</li>
  <li>它支持在客户端和服务端渲染。</li>
  <li>易于与框架（Angular，Backbone）集成，因为它只是一个视图库。</li>
  <li>使用 Jest 等工具轻松编写单元与集成测试。</li>
  <li>组件化框架，可以构建复杂应用</li>
</ul>

<h1 id="react-的局限性是什么">React 的局限性是什么?</h1>

<ul>
  <li>React 只是一个视图库，而不是一个完整的框架。</li>
  <li>对于 Web 开发初学者来说，有一个学习曲线。</li>
  <li>将 React 集成到传统的 MVC 框架中需要一些额外的配置。</li>
  <li>代码复杂性随着内联模板和 JSX 的增加而增加。</li>
</ul>

<h1 id="在-react-v16-中的错误边界是什么">在 React v16 中的错误边界是什么</h1>

<p>错误边界是在其子组件树中的任何位置捕获 JavaScript 错误、记录这些错误并显示回退 UI 而不是崩溃的组件树的组件。</p>

<p>如果一个类组件定义了一个名为 componentDidCatch(error, info) 或 static getDerivedStateFromError() 新的生命周期方法，则该类组件将成为错误边界：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ErrorBoundary</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="na">hasError</span><span class="p">:</span> <span class="kc">false</span> <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">componentDidCatch</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// You can also log the error to an error reporting service</span>
    <span class="nx">logErrorToMyService</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">getDerivedStateFromError</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// Update state so the next render will show the fallback UI.</span>
     <span class="k">return</span> <span class="p">{</span> <span class="na">hasError</span><span class="p">:</span> <span class="kc">true</span> <span class="p">};</span>
   <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">hasError</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// You can render any custom fallback UI</span>
      <span class="k">return</span> <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="si">{</span><span class="dl">'</span><span class="s1">Something went wrong.</span><span class="dl">'</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>之后，将其作为常规组件使用：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nc">ErrorBoundary</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nc">MyWidget</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nc">ErrorBoundary</span><span class="p">&gt;</span>

</code></pre></div></div>

<h1 id="在-react-v15-中如何处理错误边界">在 React v15 中如何处理错误边界?</h1>

<p>React v15 使用 unstable_handleError 方法为错误边界提供了非常基础的支持。已在 React v16 中，将其重命名为componentDidCatch。</p>

<h1 id="静态类型检查推荐的方法是什么">静态类型检查推荐的方法是什么?</h1>

<p>通常，我们使用 PropTypes 库（在 React v15.5 之后 React.PropTypes 被移动到了 prop-types 包中），在 React 应用程序中执行类型检查。对于大型项目，建议使用静态类型检查器，比如 Flow 或 TypeScript，它们在编译时执行类型检查并提供 auto-completion 功能。</p>

<h1 id="react-dom-中-render-方法的目的是什么">react-dom 中 render 方法的目的是什么?</h1>

<p>此方法用于将 React 元素渲染到所提供容器中的 DOM 结构中，并返回对组件的引用。如果 React 元素之前已被渲染到容器中，它将对其执行更新，并且只在需要时改变 DOM 以反映最新的更改。</p>

<p><code class="language-plaintext highlighter-rouge">ReactDOM.render(element, container[, callback])</code></p>

<h1 id="reactdomserver-是什么">ReactDOMServer 是什么?</h1>

<p>ReactDOMServer 对象使你能够将组件渲染为静态标记（通常用于 Node 服务器中），此对象主要用于服务端渲染（SSR）。以下方法可用于服务器和浏览器环境：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="nx">renderToString</span><span class="p">()</span>
    <span class="nx">renderToStaticMarkup</span><span class="p">()</span>

</code></pre></div></div>
<p>例如，你通常运行基于 Node 的 Web 服务器，如 Express，Hapi 或 Koa，然后你调用 renderToString 将根组件渲染为字符串，然后作为响应进行发送。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// using Express</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">renderToString</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-dom/server</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">MyPage</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./MyPage</span><span class="dl">'</span>

<span class="nx">app</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><span class="dl">'</span><span class="p">)</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;div id="content"&gt;</span><span class="dl">'</span><span class="p">)</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="nx">renderToString</span><span class="p">(</span><span class="o">&lt;</span><span class="nx">MyPage</span><span class="o">/&gt;</span><span class="p">))</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</span><span class="dl">'</span><span class="p">)</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span>
<span class="p">})</span>
</code></pre></div></div>

<p>在 React 中如何使用 innerHTML?</p>

<p>dangerouslySetInnerHTML 属性是 React 用来替代在浏览器 DOM 中使用 innerHTML。与 innerHTML 一样，考虑到跨站脚本攻击（XSS），使用此属性也是有风险的。使用时，你只需传递以 __html 作为键，而 HTML 文本作为对应值的对象。</p>

<p>在本示例中 MyComponent 组件使用 dangerouslySetInnerHTML 属性来设置 HTML 标记：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">createMarkup</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span> <span class="na">__html</span><span class="p">:</span> <span class="dl">'</span><span class="s1">First &amp;middot; Second</span><span class="dl">'</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span> <span class="na">dangerouslySetInnerHTML</span><span class="p">=</span><span class="si">{</span><span class="nx">createMarkup</span><span class="p">()</span><span class="si">}</span> <span class="p">/&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="在-react-中事件有何不同">在 React 中事件有何不同?</h1>

<p>处理 React 元素中的事件有一些语法差异：</p>

<ul>
  <li>React 事件处理程序是采用驼峰而不是小写来命名的。</li>
  <li>使用 JSX，你将传递一个函数作为事件处理程序，而不是字符串。</li>
</ul>

<h1 id="如果在构造函数中使用-setstate-会发生什么">如果在构造函数中使用 setState() 会发生什么?</h1>

<p>当你使用 setState() 时，除了设置状态对象之外，React 还会重新渲染组件及其所有的子组件。你会得到这样的错误：Can only update a mounted or mounting component.。因此我们需要在构造函数中使用 this.state 初始化状态。</p>

<h1 id="在-componentwillmount-方法中使用-setstate-好吗">在 componentWillMount() 方法中使用 setState() 好吗?</h1>

<p>建议避免在 componentWillMount() 生命周期方法中执行异步初始化。在 mounting 发生之前会立即调用 componentWillMount()，且它在 render() 之前被调用，因此在此方法中更新状态将不会触发重新渲染。应避免在此方法中引入任何副作用或订阅操作。我们需要确保对组件初始化的异步调用发生在 componentDidMount() 中，而不是在 componentWillMount() 中</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">axios</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s2">`api/todos`</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">result</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="na">messages</span><span class="p">:</span> <span class="p">[...</span><span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">]</span>
      <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>

</code></pre></div></div>

<h1 id="如果在初始状态中使用-props-属性会发生什么">如果在初始状态中使用 props 属性会发生什么?</h1>

<p>如果在不刷新组件的情况下更改组件上的属性，则不会显示新的属性值，因为构造函数函数永远不会更新组件的当前状态。只有在首次创建组件时才会用 props 属性初始化状态。</p>

<p>以下组件将不显示更新的输入值：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">records</span><span class="p">:</span> <span class="p">[],</span>
      <span class="na">inputValue</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">inputValue</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">inputValue</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在 render 方法使用使用 props 将会显示更新的值：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">record</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">inputValue</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="如何实现-server-side-rendering-或-ssr">如何实现 Server Side Rendering 或 SSR?</h1>

<p>React 已经配备了用于处理 Node 服务器上页面渲染的功能。你可以使用特殊版本的 DOM 渲染器，它遵循与客户端相同的模式。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">ReactDOMServer</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-dom/server</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">App</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./App</span><span class="dl">'</span>

<span class="nx">ReactDOMServer</span><span class="p">.</span><span class="nx">renderToString</span><span class="p">(&lt;</span><span class="nc">App</span> <span class="p">/&gt;)</span>

</code></pre></div></div>
<p>此方法将以字符串形式输出常规 HTML，然后将其作为服务器响应的一部分放在页面正文中。在客户端，React 检测预渲染的内容并无缝地衔接。</p>

<h1 id="在-mounting-阶段生命周期方法的执行顺序是什么">在 mounting 阶段生命周期方法的执行顺序是什么?</h1>

<p>在创建组件的实例并将其插入到 DOM 中时，将按以下顺序调用生命周期方法。</p>

<ul>
  <li>constructor()</li>
  <li>static getDerivedStateFromProps()</li>
  <li>render()</li>
  <li>componentDidMount()</li>
</ul>

<h1 id="命周期方法-getderivedstatefromprops-的目的是什么">命周期方法 getDerivedStateFromProps() 的目的是什么?</h1>

<p>新的静态 getDerivedStateFromProps() 生命周期方法在实例化组件之后以及重新渲染组件之前调用。它可以返回一个对象用于更新状态，或者返回 null 指示新的属性不需要任何状态更新。</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="nx">getDerivedStateFromProps</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>此生命周期方法与 componentDidUpdate() 一起涵盖了 componentWillReceiveProps() 的所有用例。</p>

<h3 id="拓展-2">拓展</h3>

<ul>
  <li><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops">getderivedstatefromprops</a></li>
</ul>

<h1 id="生命周期方法-getsnapshotbeforeupdate-的目的是什么">生命周期方法 getSnapshotBeforeUpdate() 的目的是什么?</h1>

<p>新的 getSnapshotBeforeUpdate() 生命周期方法在 DOM 更新之前被调用。此方法的返回值将作为第三个参数传递给componentDidUpdate()。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">getSnapshotBeforeUpdate</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">prevState</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>此生命周期方法与 componentDidUpdate() 一起涵盖了 componentWillUpdate() 的所有用例。</p>

<h1 id="createelement-和-cloneelement-方法有什么区别">createElement() 和 cloneElement() 方法有什么区别?</h1>

<p>JSX 元素将被转换为 React.createElement() 函数来创建 React 元素，这些对象将用于表示 UI 对象。而 cloneElement 用于克隆元素并传递新的属性。</p>

<h1 id="为什么我们需要将函数传递给-setstate-方法">为什么我们需要将函数传递给 setState() 方法?</h1>

<p>这背后的原因是 setState() 是一个异步操作。出于性能原因，React 会对状态更改进行批处理，因此在调用 setState() 方法之后，状态可能不会立即更改。这意味着当你调用 setState() 方法时，你不应该依赖当前状态，因为你不能确定当前状态应该是什么。这个问题的解决方案是将一个函数传递给 setState()，该函数会以上一个状态作为参数。通过这样做，你可以避免由于 setState() 的异步性质而导致用户在访问时获取旧状态值的问题。</p>

<p>假设初始计数值为零。在连续三次增加操作之后，该值将只增加一个。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// assuming this.state.count === 0</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">})</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">})</span>
<span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">count</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">})</span>
<span class="c1">// this.state.count === 1, not 3</span>
</code></pre></div></div>
<p>如果将函数传递给 setState()，则 count 将正确递增。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">((</span><span class="nx">prevState</span><span class="p">,</span> <span class="nx">props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="na">count</span><span class="p">:</span> <span class="nx">prevState</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="nx">props</span><span class="p">.</span><span class="nx">increment</span>
<span class="p">}))</span>
<span class="c1">// this.state.count === 3 as expected</span>
</code></pre></div></div>

<h1 id="constructor-和-getinitialstate-有什么区别">constructor 和 getInitialState 有什么区别?</h1>

<p>当使用 ES6 类时，你应该在构造函数中初始化状态，而当你使用 React.createClass() 时，就需要使用 getInitialState() 方法。</p>

<p>使用 ES6 类:</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* initial state */</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果使用 createReactClass() 方法创建组件，你需要提供一个单独的 getInitialState 方法，让其返回初始 state：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Counter</span> <span class="o">=</span> <span class="nx">createReactClass</span><span class="p">({</span>
  <span class="na">getInitialState</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="na">count</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">initialCount</span><span class="p">};</span>
  <span class="p">},</span>
  <span class="c1">// ...</span>
<span class="p">});</span>
</code></pre></div></div>

<h1 id="是否可以在不调用-setstate-方法的情况下强制组件重新渲染">是否可以在不调用 setState 方法的情况下，强制组件重新渲染?</h1>

<p>默认情况下，当组件的状态或属性改变时，组件将重新渲染。如果你的 render() 方法依赖于其他数据，你可以通过调用 forceUpdate() 来告诉 React，当前组件需要重新渲染。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">component</span><span class="p">.</span><span class="nx">forceUpdate</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span>
</code></pre></div></div>

<p>建议避免使用 forceUpdate()，并且只在 render() 方法中读取 this.props 和 this.state。</p>

<h1 id="在使用-es6-类的-react-中-super-和-superprops-有什么区别">在使用 ES6 类的 React 中 super() 和 super(props) 有什么区别?</h1>

<p>当你想要在 constructor() 函数中访问 this.props，你需要将 props 传递给 super() 方法。</p>

<p>使用 super(props):</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">)</span> <span class="c1">// { name: 'John', ... }</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>使用 super():</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">MyComponent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">)</span> <span class="c1">// undefined</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="拓展-3">拓展</h3>

<ul>
  <li><a href="https://overreacted.io/zh-hans/why-do-we-write-super-props/">why-do-we-write-super-props</a></li>
</ul>

<h1 id="react-和-reactdom-之间有什么区别">React 和 ReactDOM 之间有什么区别?</h1>

<p>react 包中包含 React.createElement(), React.Component, React.Children，以及与元素和组件类相关的其他帮助程序。你可以将这些视为构建组件所需的同构或通用帮助程序。react-dom 包中包含了 ReactDOM.render()，在 react-dom/server 包中有支持服务端渲染的 ReactDOMServer.renderToString() 和 ReactDOMServer.renderToStaticMarkup() 方法。</p>

<h1 id="为什么-reactdom-从-react-分离出来">为什么 ReactDOM 从 React 分离出来?</h1>

<p>React 团队致力于将所有的与 DOM 相关的特性抽取到一个名为 ReactDOM 的独立库中。React v0.14 是第一个拆分后的版本。通过查看一些软件包，react-native，react-art，react-canvas，和 react-three，很明显，React 的优雅和本质与浏览器或 DOM 无关。为了构建更多 React 能应用的环境，React 团队计划将主要的 React 包拆分成两个：react 和 react-dom。这为编写可以在 React 和 React Native 的 Web 版本之间共享的组件铺平了道路。</p>

<h1 id="如何使用-react-label-元素">如何使用 React label 元素?</h1>

<p>如果你尝试使用标准的 for 属性将 <label> 元素绑定到文本输入框，那么在控制台将会打印缺少 HTML 属性的警告消息。</label></p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">label</span> <span class="na">for</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="dl">'</span><span class="s1">User</span><span class="dl">'</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">label</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">text</span><span class="dl">'</span><span class="si">}</span> <span class="na">id</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="si">}</span> <span class="p">/&gt;</span>

</code></pre></div></div>
<p>因为 for 是 JavaScript 的保留字，请使用 htmlFor 来替代。</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="nt">label</span> <span class="na">htmlFor</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="dl">'</span><span class="s1">User</span><span class="dl">'</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">label</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">text</span><span class="dl">'</span><span class="si">}</span> <span class="na">id</span><span class="p">=</span><span class="si">{</span><span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="si">}</span> <span class="p">/&gt;</span>
</code></pre></div></div>

<h1 id="如何在调整浏览器大小时重新渲染视图">如何在调整浏览器大小时重新渲染视图?</h1>

<p>你可以在 componentDidMount() 中监听 resize 事件，然后更新尺寸（width 和 height）。你应该在 componentWillUnmount() 方法中移除监听。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">WindowDimensions</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">width</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="na">height</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">updateDimensions</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">resize</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">updateDimensions</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">componentWillUnmount</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">window</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">resize</span><span class="dl">'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">updateDimensions</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">updateDimensions</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">resize</span><span class="dl">'</span><span class="p">)</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">width</span><span class="p">:</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerWidth</span><span class="p">,</span> <span class="na">height</span><span class="p">:</span> <span class="nb">window</span><span class="p">.</span><span class="nx">innerHeight</span> <span class="p">})</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">width</span><span class="si">}</span> x <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">height</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="最流行的动画软件包是什么">最流行的动画软件包是什么?</h1>

<p>React Transition Group 和 React Motion 是React生态系统中流行的动画包。</p>

<h1 id="如何发起-ajax-调用以及应该在哪些组件生命周期方法中进行-ajax-调用">如何发起 AJAX 调用以及应该在哪些组件生命周期方法中进行 AJAX 调用?</h1>

<p>你可以使用 AJAX 库，如 Axios，jQuery AJAX 和浏览器内置的 fetch API。你应该在 componentDidMount() 生命周期方法中获取数据。这样当获取到数据的时候，你就可以使用 setState() 方法来更新你的组件。</p>

<h1 id="react-memo-函数是什么">React memo 函数是什么?</h1>

<p>当类组件的输入属性相同时，可以使用 pureComponent 或 shouldComponentUpdate 来避免组件的渲染。现在，你可以通过把函数组件包装在 React.memo 中来实现相同的功能。</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyComponent</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">memo</span><span class="p">(</span><span class="kd">function</span> <span class="nx">MyComponent</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
 <span class="cm">/* only rerenders if props change */</span>
<span class="p">});</span>
</code></pre></div></div>

<h1 id="什么是-hooks">什么是 hooks?</h1>

<p>Hooks 是一个新的草案，它允许你在不编写类的情况下使用状态和其他 React 特性。让我们来看一个 useState 钩子示例：</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Example</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Declare a new state variable, which we'll call "count"</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>You clicked <span class="si">{</span><span class="nx">count</span><span class="si">}</span> times<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
        Click me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<h1 id="hooks-需要遵循什么规则">Hooks 需要遵循什么规则?</h1>

<p>为了使用 hooks，你需要遵守两个规则：</p>

<ul>
  <li>
    <p>仅在顶层的 React 函数调用 hooks。也就是说，你不能在循环、条件或内嵌函数中调用 hooks。这将确保每次组件渲染时都以相同的顺序调用 hooks，并且它会在多个 useState 和 useEffect 调用之间保留 hooks 的状态。</p>
  </li>
  <li>
    <p>仅在 React 函数中调用 hooks。例如，你不能在常规的 JavaScript 函数中调用 hooks。</p>
  </li>
</ul>

<h1 id="什么是代码拆分">什么是代码拆分?</h1>

<p>Code-Splitting 是 Webpack 和 Browserify 等打包工具所支持的一项功能，它可以创建多个 bundles，并可以在运行时动态加载。React 项目支持通过 dynamic import() 特性进行代码拆分。例如，在下面的代码片段中，它将使 moduleA.js 及其所有唯一依赖项作为单独的块，仅当用户点击 ‘Load’ 按钮后才加载。</p>

<p>moduleA.js</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">moduleA</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello</span><span class="dl">'</span><span class="p">;</span>

<span class="k">export</span> <span class="p">{</span> <span class="nx">moduleA</span> <span class="p">};</span>

</code></pre></div></div>
<p>App.js</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">Component</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">import</span><span class="p">(</span><span class="dl">'</span><span class="s1">./moduleA</span><span class="dl">'</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(({</span> <span class="nx">moduleA</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Use moduleA</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="c1">// Handle failure</span>
      <span class="p">});</span>
  <span class="p">};</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>Load<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">App</span><span class="p">;</span>

</code></pre></div></div>

<h1 id="react-router">React Router</h1>

<ul>
  <li><a href="/%E5%89%8D%E7%AB%AF/react/reactrouter/2021/02/28/ReactRouter%E9%97%AE%E9%A2%98.html">ReactRouter问题</a></li>
</ul>

<h1 id="react-redux">React Redux</h1>

<ul>
  <li><a href="/%E5%89%8D%E7%AB%AF/react/reactredux/2021/02/28/ReactRedux%E9%97%AE%E9%A2%98.html">ReactRedux问题</a></li>
</ul>

<h1 id="参考-2">参考</h1>

<ul>
  <li>
    <p><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#gatsby-focus-wrapper">React Doc</a></p>
  </li>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/165982030?utm_source=wechat_session">React问题梳理</a></p>
  </li>
  <li>
    <p><a href="https://github.com/semlinker/reactjs-interview-questions">React问题</a></p>
  </li>
</ul>

  </div>

  <footer class="article-footer">

  <!-- <section class="share">
  <a class="share-link" href="" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
    Twitter
  </a>
  <a class="share-link" href="" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
    Facebook
  </a>
  <a class="share-link" href="" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530'); return false;">
    Google+
  </a> 
</section>
 -->


  <section class="author">
  <div class="authorimage box" style="background: url(/assets/img/Mark24.jpg)"></div>
  <div class="authorinfo box">
    <p>Mark24</p>
    <p class="bio">Everything can Mix.</p>
  </div>
</section>


  </footer>

  
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'mark24code';
    var disqus_identifier = '/%E5%89%8D%E7%AB%AF/react/2020/04/18/React关键问题01';
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>



</article>

          </div>
        </div>
      </div>
      <footer class="site-footer">
  <div class="container" style="padding: 10px 32px;">
    <div class="footer left column one-half">
      <section class="small-font">
        © 2020 
        Powered by <a href="https://github.com/jekyll/jekyll">jekyll</a>
      </section>
    </div>

    <!-- <div class="footer right column one-half">
      <section class="small-font">
        
        <a href="https://github.com/Mark24Code"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span></a>

        
        
      </section>
    </div> -->
  </div>
</footer>
 
    </div>
  </body>
</html>
